/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core'; // Workbox nos soluciona muchas cosas de las estrategias de caché
import { precacheAndRoute } from 'workbox-precaching';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Borré todo lo de abajo, me quedé con el precache

const CACHE_STATIC = 'cache-static-v1'; // Agrego un const para manejar esa url desde este const
const CACHE_DYNAMIC = 'cache-dynamic-v1';
const CACHE_IMMUTABLE = 'cache-inmutable-v1';

const APP_SHELL = [ // Pongo el iconito de react, el que aparece en la pestaña, y el index y todo lo que está en public que quiero guardar
  '/',
  '/index.html',
  '/favicon.ico'
];

const APP_SHELL_IMMUTABLE = []; // Juani puso la fuente Roboto acá, el link de fonts.googleapis.com

self.addEventListener('fetch', function(event) {
  event.respondWith(
      caches.match(event.request).then(function(response) {
          return response || fetch(event.request);
      })
  );
});

self.addEventListener('install', event => {
  const promise1 = caches.open(CACHE_STATIC) // Va a tratar de abrir la cache static definida más arriba
    .then(cache => {
      cache.addAll(APP_SHELL); // Incorpora todo dentro de un array, en este caso APP_SHELL
    });
  
  const promise2 = caches.open(CACHE_IMMUTABLE) // Lo mismo pero con la inmutable
    .then(cache => {
      cache.addAll(APP_SHELL_IMMUTABLE);
    });

  event.waitUntil(Promise.all([promise1, promise2])); // Promise.all espera un array de promesas, y las espera todas
});

self.addEventListener('activate', event => {
  const response = caches.keys() // Trae todos los nombres de las cache que tenga almacenada la api cache
    .then(keys => {
      keys.forEach(key => { // Recorremos las keys (nombres de las caches)
        if(key != CACHE_STATIC && key.includes('static')) { // Vemos si el nombre es distinto al de static, y también que incluya en su nombre el string 'static'
          // Si entro acá, el nombre es distinto y contiene el static en su nombre
          return caches.delete(key); // Limpia la caché. Returna true o false, dependiendo si la pudo borrar o no. No nos importa por ahora lo que devuelva
        }
      });
    });

  event.waitUntil(response); // Banca hasta que termine la promesa del response
});

